#include "include/linux.h"

#define USE_MMAP_FO 1

struct Extent {
     int size;
     char *buf;
};

#if !(USE_MMAP_FO)
#if 1
static __inline__ int xwrite(int fd, const void *buf, int count)
{

     do {
          int n = write(fd, buf, count);
          if (n == -EINTR)
               continue;
          if (n <= 0)
               break;
          buf += n;
          count -= n;
     } while (count > 0);
     return count;
}
#else
#define xwrite(fd,buf,count) ((count)-write(fd, buf, count))
#endif
#endif

#if 1

extern char *__attribute__((regparm(2), stdcall)) upx_itoa(unsigned long v, char *buf);

#else

static char *upx_itoa(unsigned long v, char *buf)
{

     volatile unsigned TEN = 10;
     char * p = buf;
     {
          unsigned long k = v;
          do {
               p++;
               k /= TEN;
          } while (k > 0);
     }
     buf = p;
     *p = 0;
     {
          unsigned long k = v;
          do {
               *--p = '0' + k % TEN;
               k /= TEN;
          } while (k > 0);
     }
     return buf;
}

#endif

static uint32_t ascii5(char *p, uint32_t v, unsigned n)
{
     do {
          unsigned char d = v % 32;
          if (d >= 26)
               d -= 43;
          *--p = (d += 'A');
          v /= 32;
     } while (--n > 0);
     return v;
}

extern char *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);

#if defined(__i386__)
#define SET2(p,c0,c1) *(unsigned short *)(p) = ((c1) << 8 | (c0))
#define SET4(p,c0,c1,c2,c3) *(uint32_t *)(p) = ((c3) << 24 | (c2) << 16 | (c1) << 8 | (c0))
#define SET3(p,c0,c1,c2) SET4(p, c0, c1, c2, 0)
#else
#define SET2(p,c0,c1) (p)[0] = c0, (p)[1] = c1
#define SET3(p,c0,c1,c2) (p)[0] = c0, (p)[1] = c1, (p)[2] = c2
#define SET4(p,c0,c1,c2,c3) (p)[0] = c0, (p)[1] = c1, (p)[2] = c2, (p)[3] = c3
#endif

static int
#if (ACC_CC_GNUC >= 0x030300)
   __attribute__((__noinline__, __used__, __stdcall__))
#endif
   go_self(char const *tmpname, char *argv[], char *envp[])
{

     int const fdi = open(tmpname, O_RDONLY, 0);

     if (0 <= fdi) {

          char procself_buf[31 + 1];

          SET4(procself_buf + 0, '/', 'p', 'r', 'o');
          SET4(procself_buf + 4, 'c', '/', 0, 0);
          {
               char *const procself = upx_itoa(getpid(), procself_buf + 6);
               SET4(procself, '/', 'f', 'd', '/');
               upx_itoa(fdi, procself + 4);
          }

          if (UPX2 == (unsigned)access(procself_buf, R_OK | X_OK)) {

               unlink(tmpname);

               fcntl(fdi, F_SETFD, FD_CLOEXEC);

               execve(procself_buf, argv, envp);
               unsigned const lenf = lseek(fdi, 0, SEEK_END);
               char *const buf = mmap((char *)0, lenf, PROT_READ | PROT_WRITE, MAP_PRIVATE, fdi, 0);
               int const fdo = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, 0700);
               if (lenf != (unsigned)write(fdo, buf, lenf)) {
                    exit(127);
               }
               close(fdo);
          }

          close(fdi);
     }
     return fdi;
}

typedef void f_unfilter(nrv_byte *, nrv_uint, unsigned cto8);
typedef int f_expand(const nrv_byte *src, nrv_uint src_len, nrv_byte *dst, nrv_uint *dst_len, int method);
void upx_main(struct Extent xi,
                      f_expand *const f_decompress,
                      int junk2,
                      f_unfilter *const f_unf,
                      char * envp[],
                      char * argv[],
                      int argc) __asm__("upx_main");
void upx_main(struct Extent xi,
                      f_expand *const f_decompress,
                      int junk,
                      f_unfilter *const f_unf,
                      char * envp[],
                      char * argv[],
                      int argc)
{

     int fdo;

     unsigned char *buf;

     char * tmpname;
     struct p_info header;

     char tmpname_buf[20];

     (void)junk;
     {
          register char *__d0, *__d1;
          __asm__ __volatile__("movsl; movsl; movsl" : "=&D"(__d0), "=&S"(__d1) : "0"(&header), "1"(xi.buf) : "memory");
          xi.buf = __d1;
          xi.size -= sizeof(header);
     }

     if (header.p_progid != UPX3)
          goto error1;

     tmpname = tmpname_buf;
     SET4(tmpname + 0, '/', 't', 'm', 'p');
     SET4(tmpname + 4, '/', 'u', 'p', 'x');

     {
          char *p = tmpname_buf + sizeof(tmpname_buf) - 1;

          uint32_t r = ascii5(p, (uint32_t)getpid(), 4);
          *p = '\0';
          p -= 4;

          r ^= header.p_progid;

          {
#if 1
               struct timeval tv;
               gettimeofday(&tv, 0);
               r ^= (uint32_t)tv.tv_sec;
               r ^= ((uint32_t)tv.tv_usec) << 12;
#else

               struct timex tx;
               adjtimex(&tx);
               r ^= (uint32_t)tx.time.tv_sec;
               r ^= ((uint32_t)tx.time.tv_usec) << 12;
               r ^= (uint32_t)tx.errcnt;
#endif
          }

          ascii5(p, r, 7);
     }

     {
          int err = unlink(tmpname);
          if (err != -ENOENT && err != 0)
               goto error1;
     }

#if (USE_MMAP_FO)
     fdo = open(tmpname, O_RDWR | O_CREAT | O_EXCL, 0700);
#else
     fdo = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, 0700);
#endif
#if 0

    if (fdo < 0)
        goto error;
#endif

     if (ftruncate(fdo, header.p_filesize) != 0)
          goto error;

#if (USE_MMAP_FO)

     buf = (unsigned char *)mmap(0, header.p_filesize, PROT_READ | PROT_WRITE, MAP_SHARED, fdo, 0);
     if ((unsigned long)buf >= (unsigned long)-4095)
          goto error;

     mmap(buf + (PAGE_MASK & (header.p_filesize + ~PAGE_MASK)),
          -PAGE_MASK,
          PROT_READ | PROT_WRITE,
          MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,
          -1,
          0);
#else

     buf = mmap(0,
                (header.p_blocksize + OVERHEAD + ~PAGE_MASK) & PAGE_MASK,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS,
                -1,
                0);
     if ((unsigned long)buf >= (unsigned long)-4095)
          goto error;
#endif

     for (;;) {
          struct b_info h;

          {
               register char *__d0, *__d1;
               __asm__ __volatile__("movsl; movsl; movsl" : "=&D"(__d0), "=&S"(__d1) : "0"(&h), "1"(xi.buf) : "memory");
               xi.buf = __d1;
               xi.size -= sizeof(h);
          }
          if (h.sz_unc == 0) {
               if (h.sz_cpr != UPX_MAGIC_LE32)
                    goto error;
               if (header.p_filesize != 0)
                    goto error;
               break;
          }

          if (h.sz_cpr > h.sz_unc || h.sz_cpr > header.p_blocksize)
               goto error;

          if (h.sz_cpr < h.sz_unc) {
               nrv_uint out_len = h.sz_unc;
               int i = (*f_decompress)((unsigned char *)xi.buf, h.sz_cpr, buf, &out_len, *(int *)(void *)&h.b_method);
               if (i != 0 || out_len != (nrv_uint)h.sz_unc)
                    goto error;

               (void)f_unf;
          }
          else {

#if (USE_MMAP_FO)

               register unsigned long int __d0, __d1, __d2;
               __asm__ __volatile__("rep; movsb"
                                    : "=&c"(__d0), "=&D"(__d1), "=&S"(__d2)
                                    : "0"(h.sz_unc), "1"(buf), "2"(xi.buf)
                                    : "memory");
#endif
          }

#if (USE_MMAP_FO)

          munmap(buf, h.sz_unc);
          buf += h.sz_unc;
#else

          if (xwrite(fdo, buf, h.sz_unc) != 0)
               goto error;
#endif

          header.p_filesize -= h.sz_unc;

          xi.buf += h.sz_cpr;
          xi.size -= h.sz_cpr;

          if (xi.size < 0) {

          error:
               (void)unlink(tmpname);
          error1:

               for (;;)
                    (void)exit(127);
          }
     }

#if !(USE_MMAP_FO)

     munmap(buf, malloc_args.ma_length);
#endif

     if (close(fdo) != 0)
          goto error;
     if (0 > go_self(tmpname, argv, envp))
          goto error;
     if (fork() == 0) {
          if (fork() == 0) {

               struct timespec ts;
               ts.tv_sec = UPX4;
               ts.tv_nsec = 0;
               nanosleep(&ts, 0);
               unlink(tmpname);
          }
          exit(0);
     }

     waitpid(-1, (int *)0, 0);

     (void)argc;
     execve(tmpname, argv, envp);

     goto error;
}
